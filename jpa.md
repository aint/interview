### The entity states

- `Transient` a newly created object that hasn’t ever been associated with a Persistence Context and is not mapped to any database table row.
- `Persistent (Managed)` associated with a database table row and it’s being managed by the current running Persistence Context.
- `Detached` when the current running Persistence Context is closed. Can be:
	- `Reattaching` via `Session#update` (only Hibernate)
	- `Merging` copy the detached entity state to a managed entity instance. The detached object instance will continue to remain detached even after the merge operation
- `Removed` scheduled for deletion and the actual database DELETE statement will be executed

![jpaentitystates.png](#file:d2035fd3-f4da-c02d-8884-090b336477ec)

- The `persist` operation must be used only for new entities
For `IDENTITY` columns, Hibernate cannot delay the **INSERT** statement until flush time because the identifier value can only be generated by executing the statement.
- `Merge` is required only for detached entities
Hibernate generates a **SELECT** statement first to fetch the latest state of the underlying database record, and afterward, it copies the detached entity state onto the newly fetched managed entity.
If identifier is manually assigned we can avoid a redundant **SELECT** statement by adding. `@Version` property
- The `CrudRepository.save` method serves **no purpose**   The redundant save anti-pattern
Even without it, Hibernate will still issue the **UPDATE** statement since the entity is managed and any state change is propagated as long as the currently running *EntityManager* is open.

### Flushing strategies

- `FlushModeType.AUTO` (_default_) flushes changes on commit as well as every query execution.
- `FlushModeType.COMMIT` flush will occur only on commit
- `FlushMode.ALWAYS` the Session is always flushed before query execution
- `FlushMode.MANUAL` the Session can only be manually flushed.


### Cache Levels

##### L1 cache == Persistence Context (EntityManager)
A persistence context is a set of entity instances in which for any persistent entity identity there is a unique entity instance. Within the persistence context, the entity instances and their lifecycle are managed.
```java
em.persist(entity); // saves entity to the context
em.flush();         // triggers insert into database
m.clear();          // removes entity from the context == entity is no longer managed
```

##### L2 cache
Second level cache has hash table like structure internally to hold the data. The Key here will be the identifier of the entity and value will be dehydrated values of the entity. To get the data out of this L2 cache, you must have a Key (identifier of the entity). So clearly **you can use it with methods where you are fetching entity by id**.

##### Query cache
Query cache stores the query and it's corresponding resultset entities' ids. Now even if you are not fetching by id (using JPQL or HQL), hibernate checks if the same query is fired earlier and if yes get the list of ids from the query cache. After that returns the entities from L2 cache corresponding to same ids.



Strategies:
- **Read-only**: used only for entities that never change (exception is thrown if an attempt to update such an entity is made)
- **Read-write**: when a cached entity is updated, a soft lock is stored in the cache for that entity as well, which is released after the transaction is committed. All concurrent transactions that access soft-locked entries will fetch the corresponding data directly from database
- **Nonstrict-read-write**: cache is updated after a transaction that changed the affected data has been committed. Thus, strong consistency is not guaranteed and there is a small time window in which stale data may be obtained from cache.
- **Transactional**: cache changes are done in distributed XA transactions. A change in a cached entity is either committed or rolled back in both database and cache in the same XA transaction


### Primary keys generation types

`@GeneratedValue(strategy=GenerationType.???)`

- `AUTO` the default generation type and lets the persistence provider choose the generation strategy.
- `IDENTITY` relies on an auto-incremented (identity) database column and lets the database generate a new value with each insert operation.
We can’t know the newly assigned value prior to executing the INSERT statement. **Hibernate** requires a primary key value for each managed entity and therefore has to perform the insert statement **immediately**. This prevents it from using different optimization techniques like JDBC batching.
- `SEQUENCE` uses a database sequence to generate unique values
It requires **additional select** statements to get the next value from a database sequence. But this has no performance impact for most applications.
- `TABLE` It simulates a sequence by storing and updating its current value in a database table which requires the use of pessimistic locks which put all transactions into a sequential order.
- `Custom`
```java
@GenericGenerator(name = \"id_gen\", strategy = \"CustomIdGenerator\")
@GeneratedValue(generator = \"id_gen\")
...
class CustomIdGenerator implements IdentifierGenerator { ... }
```

### Fetching strategies

- **Join** loads all the collections and entities using `OUTER JOINED` in the original `SELECT` statement
- **Select** (default) an additional `SELECT` statement is used to retrieve the associated entity(entities)
- **Subselect**	an additional `SELECT` statement is used to retrieve the whole associated collection. This mode is meant for `to-many` associations
- **Batch (N)**	an additional number of `SELECT` statements is used to retrieve the whole associated collection. Each additional `SELECT` will retrieve a fixed number **N** of associated entities. This mode is meant for `to-many` associations


### Relationship & cascade

The bidirectional associations should always be updated on both sides, therefore the **Parent** side should contain the **addChild** and **removeChild** combo. These methods ensure we always synchronize both sides of the association, to avoid object or relational data corruption issues.

Most often, the **Parent** entity is the inverse side (e.g. **mappedBy**), the **Child** controlling the association through its *Foreign Key*.

- Bidirectional `@OneToMany`
  ```java
  @OneToMany(mappedBy = "parent",
             cascade = CascadeType.ALL,
             orphanRemoval = true)
  private List<Child> childList = new ArrayList<>();

  public void addComment(Child child) {
      childList.add(child);
      childList.setParent(this);
  }

  public void removeChild(Child child) {
      childList.remove(comment);
      childList.setParent(null);
  }
  ...
  @ManyToOne(fetch = FetchType.LAZY)
  @JoinColumn(name = "parent_id")
  private Parent parent;
   ```
	- The parent entity features two utility methods (e.g. **addChild** and **removeChild**) which are used to synchronize both sides of the bidirectional association.
	- The child entity, implement the **equals** and **hashCode** methods. Because we rely on equality for the removeComment, it’s good practice to override equals and hashCode for the child entity in a bidirectional association.
- `@ManyToMany` and **CascadeType.ALL(REMOVE)**
    - it is almost always a bug to cascade REMOVE operation in a @ManyToMany association, because that would trigger removing child instances which may be associated with other parent instances.


### Mapping

#### Basic

- `@Entity(name)` names entity for using in HQL, etc, whereas `@Table(name)` names a table in db
- `@Table(indexes = { @Index(name = "MYIDX1", columnList = "id, name") })` the table annotation gives ability to create **index**
- `@Basic(fetch, optional)` allow you to specify whether the attribute is to be lazily loaded and whether it's nullable.
- Overriding attributes of class/property
  ```java
  // rename the basic mappings
  @AttributeOverride(name="NAME", column=@Column(name="LARGE_P_NAME"))
  public class LargeProject extends Project { ... }

  // rename the relationship
  @AssociationOverride(name = "location",
                       joinColumns = @JoinColumn(name = "LOCATION_ID"))
  private User employee;
  ```
- `@Access(AccessType.FIELD/PROPERTY)` defines the access type of the class, which is either FIELD or PROPERTY. The default is assumed to occur based on where the `@Id` annotation is placed, if placed on a field, then the class is using FIELD access, if placed on a **get** method, then the class is using PROPERTY access.
- `@Column(name = "myColumn", nullable = false, columnDefinition = "int default 100")`,  but note that **columnDefinition** is used during DDL phase to create your table and NOT during normal program running.
- Set `readOnly` to "true" on **Queries** and **Criteria**, when objects returned will never be modified.
- `@Immutable` mark an **Entity**, a **Collection**, or an **Attribute** type as immutable. Hibernate knows that it doesn’t have to perform any dirty checks on these entities because they’re immutable. That could result in a better performance.

### Inheritance strategies

- `@MappedSuperclass` maps each concrete class to its own table, but a mapped superclass is not an entity, and there is no table for it.
- `@Inheritance(strategy = TABLE_PER_CLASS)` is similar to the mapped superclass strategy. The main difference is that the superclass is now also an entity.
- `@Inheritance(strategy = JOINED)` a table is defined for each class in the inheritance hierarchy to store only the **local attributes of that class**. Each table in the hierarchy must also store the object's id (primary key), which is only defined in the root class.
  - `PrimaryKeyJoinColumn` it is used to join the primary table of an entity subclass to the primary table of its superclass
  ```java
    @Entity
    @Inheritance(strategy=JOINED)
    public class Customer { ... }

    @Entity
    @PrimaryKeyJoinColumn(referencedColumnName="CUST_ID")
    public class ValuedCustomer extends Customer { ... }

    @Entity
    @PrimaryKeyJoinColumn(referencedColumnName="CUST_ID")
    public class RegularCustomer extends Customer { ... }

  // Customer(id)
  // ValuedCustomer(id (FK), ...)
  // RegularCustomer(id (FK), ...)
  ```
- `@Inheritance(strategy = SINGLE_TABLE)` is the simplest and typically the best performing and best solution. In single table inheritance a single table is used to store all of the instances of the entire inheritance hierarchy
  - `@DiscriminatorColumn` specifies the name of discriminator column which stores the values to identify type of entity in database.
  - `@DiscriminatorValue` used to specify the value of the discriminator column for entities of the given type. The DiscriminatorValue annotation can only be specified on a concrete entity class.
  ```java
    @Entity
    @Inheritance(strategy = SINGLE_TABLE)
    @DiscriminatorColumn(name = "type")
    public class Customer { ... }

    @Entity
    @DiscriminatorValue(value = "VC")
    public class ValuedCustomer extends Customer { ... }

    @Entity
    @DiscriminatorValue(value = "RC")
    public class RegularCustomer extends Customer { ... }

  // Customer(id, type, ...)
  ```


### Misc

- `Serializable` is not required by JPA spec. If an entity instance is to be passed by value as a detached object (e.g., through a remote interface), the entity class must implement the Serializable interface.
So, strictly speaking, this is not a requirement unless you need detached entities to be sent over the wire to another tier, to be migrated to another cluster node, to be stored in the HTTP session, etc.

- JPA **persistence.xml**
  ```xml
  <persistence-unit name="somename" transaction-type="?">
  ```
  - `RESOURCE_LOCAL`  you are responsible for **EntityManager** (Transaction/Cache) creating and tracking
  - `JTA` he container will do **EntityManager** (Transaction/Cache) creating and tracking.
- `hibernate.jdbc.batch_size` a non-zero value enables use of JDBC2 batch updates by Hibernate (e.g. recommended values between 5 and 30). `INSERT` statements are batched, while the `UPDATE` statements are left untouched
	- Hibernate can sort `INSERT` and `UPDATE` statements using the following configuration options
		- `hibernate.order_inserts`
		- `hibernate.order_updates`
        - `hibernate.jdbc.batch_versioned_data`
- `AttributeConverter` converts entity attribute state into database column representation and back again.
- `@ColumnTransformer` allows to provide an SQL expression which Hibernate will use when reading from or writing to the database column
  ```java
  @ColumnTransformer(read = "pgp_sym_decrypt(creditCardNumber, 'mySecretKey')", write = "pgp_sym_encrypt(?, 'mySecretKey')")
  private String creditCardNumber;
  ```
- `@Formula/@OrderBy`
- `JPQL` supports the set of database functions in the SELECT and WHERE clause of your queries: _upper, lower, trim, abs, substring, size_ etc.
  ```java
  Query q = em.createQuery("SELECT a, size(a.books) FROM Author a GROUP BY a.id");
   ```

- __Hibernate SQL operations order__

	- inserts
	- updates
	- deletions of collections elements
	- inserts of the collection elements
	- deletes

- __Always check entity ID for null when using it for equals & hashCode__
When the entity was first stored in the Set, the **ID** was **null**. After the entity was persisted, the **ID** was assigned to a value that was automatically generated, hence the hashCode differs. For this reason, the entity cannot be found in the Set after it got persisted.

#### Static metamodel
When you write a criteria query or create a dynamic entity graph, you need to reference the entity classes and their attributes.
```java
@Generated(value = "org.hibernate.jpamodelgen.JPAMetaModelEntityProcessor")
@StaticMetamodel(Author.class)
public abstract class Author_ {
	public static volatile SingularAttribute<Author, Long> id;
	public static volatile SingularAttribute<Author, String> fullName;
	public static volatile SetAttribute<Author, Book> books;
}
...
query.where(cb.like(a.get(Author_.firstName), "J%"));
```

#### Entity Graph

```java
@NamedEntityGraph(
		name = "Order.items",
		attributeNodes = @NamedAttributeNode(value = "items", subgraph = "items"),
		subgraphs = @NamedSubgraph(name = "items",
                                   attributeNodes = @NamedAttributeNode("product"))
)
...
EntityGraph<Order> graph = em.createEntityGraph(Order.class);
graph.addAttributeNodes("items");

Map<String, Object> hints = new HashMap<String, Object>();
hints.put("javax.persistence.loadgraph", graph);

em.find(Order.class, orderId, hints);
```
- `javax.persistence.loadgraph` a load graph consists of the fields explicitly specified in the **EntityGraph** instance plus any fields in the default entity graph.
- `javax.persistence.fetchgraph` a fetch graph consists of only the fields **explicitly** specified via `addAttributeNodes(...)` in the **EntityGraph** instance, and ignores the default entity graph settings.


### Native Queries

##### Result Set Mapping

- `createNativeQuery(String sqlString, Class resultClass)` for default mapping
- `createNativeQuery(String sqlString, String resultSetMapping)` for custom mapping. `@SqlResultSetMappings` map the native query result to a POJO
    - `@ConstructorResult` defines the mapping between the column name and the entity constructor
      ```java
      @SqlResultSetMapping(
              name = "BookValueMapping",
              classes = @ConstructorResult(
                      targetClass = BookValue.class,
                      columns = { @ColumnResult(name = "title"),
                                  @ColumnResult(name = "date") }
              )
      )
      ```

	- `@EntityResult` defines the mapping between the column name and the entity property

      ```java
      @SqlResultSetMapping(
              name = "AuthorMapping",
              entities = @EntityResult(
                      entityClass = Author.class,
                      fields = { @FieldResult(name = "id", column = "authorId"),
                                 @FieldResult(name = "firstName", column = "firstName")}
              )
      )
      ```
	- `@ColumnResult` can defines an additional mapping: `SELECT a.id, a.firstName, count(b.id) as bookCount ...`

      ```java
      @SqlResultSetMapping(
              name = "AuthorBookCountMapping",
              entities = @EntityResult(
                      entityClass = Author.class,
                      fields = { @FieldResult(name = "id", column = "authorId"),
                                 @FieldResult(name = "firstName", column = "firstName")}
              ),
              columns = @ColumnResult(name = "bookCount", type = Long.class))
      )
      ```

- Hibernate aliases

  ```java
  List<Object[]> results = session.createSQLQuery("SELECT {a.*}, count(b.id) as bookCount ...")
                                  .addEntity(Author.class)
                                  .addScalar("bookCount", StandardBasicTypes.LONG)
                                  .list();
  ```


### dirty checking mechanism
Hibernate default dirty checking mechanism will match all mapped properties of all currently attached entities against their initial loading-time values.
The automatic dirty checking feature of hibernate, calls update statement automatically on the objects that are modified in a transaction.
```java
Employee e1 = (Employee) session1.get(Employee.class, 101);
e1.setSalary(70000);
tx.commit();
```
After changing the state, we are committing the transaction. In such case, state will be updated automatically. This is known as dirty checking in hibernate.