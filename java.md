## General
- to use try with resources we should implement the **AutoCloseable** interface
- best practices to handle exceptions
	1. clean up resources in a finally block or use a try-with-wesource statement
	2. preffer the more specific exception under a common exception
	3. document the exceptions you specify using javadoc's `@throws` declaration
	4. throw exceptions with descriptive messages
	5. don’t catch **Throwable**, because we can nothing to handle **Errors**
	6. don’t ignore exceptions
- Strings that are the values of **constant expressions** - are "interned" so as to share unique instances, using the method `String.intern`:
	```java
	String str1 = "Hel" + "lo";
	String hel = "Hel"; String lo = "lo";
	String str2 = hel + lo;
	"Hello" == str1  // true
	"Hello" == str2  // false
	str2 == str1   // false
	```
- to create an immutable class
	- Declare the class as final so it can’t be extended
	- Make all fields private so that direct access is not allowed
	- Don’t provide setter methods for variables
	- Make all mutable fields final so that it’s value can be assigned only once
	- Initialize all the fields via a *constructor performing deep copy*
	- *Perform cloning of objects in the getter methods* to return a copy rather than returning the actual object reference

#### Object

- `equals()`
 	- reflexive = x.equals(x)
	- symmetric = x.equals(y), y.equals(x)
	- transitive = x.equals(y), y.equals(z), x.equals(z)
	- consistent = multiple x.equals(y)
	- rules:
		- if the rval is **null**, it’s not equal.
		- if the rval is **this**, the two objects are equal
		- if the rval is not the same class or subclass (**instanceof**), the two objects are not equal
		- if all the above checks pass, then you must decide which fields in the rval are important (and consistent), and compare those
- `hashCode()`
	- if a hash code of two objects are the same it **not implies** objects equality
	- if two objects are equal that their hash codes **should** be the same
- `toString(), getClass(), clone()`
- `notify(), notifyAll(), wait()`
- `finalize()`
	- there is no guarantee that this method will and when be called on GC
	- all objects with this overrided method treated in some specific way by GC
	- finalize method is that it's not **automatically chained** like constructors. If you are overriding finalize method then it's your responsibility to call `finalize()` method of the superclass
	- finalize gets called only once by GC thread if object revives itself from finalize method than finalize will not be called again
	- any **Exception** is thrown by finalize method is ignored by GC thread and it will not be propagated further


##### All approaches to create object
- **new** keyword
- `Class.forName(className).newInstance()`
- **Class Loader** `Test.class.getClassLoader().loadClass("Test").newInstance()`
- **deserialization** & **cloning**


#### Anonymous class

When you create an instance of an anonymous inner class, **any variables which are used** within that class **have their values copied** in via the autogenerated constructor.
Thus it would look odd if the variable could be modified by the rest of the method - you could have code which appeared to be working with an out-of-date variable. Likewise if you could make changes within the anonymous inner class, developers might expect those changes to be visible within the body of the enclosing method.
Making the **variable final** removes all these possibilities - as the value can't be changed at all.


-----


## Inheritence

**All top-level classes are, by definition, static.** What the static boils down to is that an instance of the class can stand on its own. Or, the other way around: a non-static inner class (= instance inner class) cannot exist without an instance of the outer class. Since a top-level class does not have an outer class, it can't be anything but static.

- class modifiers: abstract, final, static, strictfp
- method modifiers: abstract, final, static, strictfp, native, synchronized
- field modifiers: static, final, transient, volatile

All interface's (except default, static and private) methods are "public abstract" and all fields are "public static final" by default.



- The diamond problem with interface's default method can be fixed with overriding a method
	- `MyInterface.super.defaultMethod()` to call default method from parent interface
- **Constructors must not invoke overridable methods**, directly or indirectly. The superclass constructor runs before the subclass constructor, so the **overriding method in the subclass** will be invoked before the subclass constructor has run. If the overriding method depends on any initialization performed by the subclass constructor, the method will not behave as expected.
	```java
    public class Foo {
    	private String foo = "foo";
        public Foo() {
            printValue();
        }
        public void printValue() { System.out.println(foo); }
    }
    public class Bar extends Foo {
    	private String bar = "bar";
        public void printValue() { System.out.println(bar); }
    }

    ...
    new Bar(); // prints null
	```


-----


## Generics

Java’s generic type parameters are **invariant**. This means for any distinct types **A** and **B**, `G<a>` is not a subtype or supertype of `G<b>`. As a real world example, `List<String>` is not a supertype or subtype of `List<Object>`.

To put **Integer** objects into a list and to maximize flexibility, we can use `List<Integer>`, `List<Number>`, and `List<Object>` — anything that can hold **Integer** values.
```java
List<Number> list = new ArrayList<>();
list.add(1);
list.add(2.2d);
Number n = list.get(0);
Double d = (Double) list.get(1);
```


#### PECS

"PECS" is from the collection's point of view.

**PRODUCER:** When want to go through the collection and do things with each item - then the list is a **producer**, so we should use `Collection<? extends Thing>`.
This collection could hold any subtype of **Thing**, and thus each element will behave as a **Thing** when you perform your operation. (You actually cannot add anything to a `Collection<? extends Thing>`, because you cannot know at runtime which specific subtype of **Thing** the collection holds.)

**CONSUMER**: When want to add things to the collection - then the list is a **consumer**, so we should use `Collection<? super Thing>`.
This collection can always hold a **Thing** no matter what the actual parameterized type is. Here you don't care what is already in the list as long as it will allow a **Thing** to be added.



- Covariance - `<? extends MyClass>`
- Contravariance - `<? super MyClass>`
- Invariance/non-Variance - `MyClass`



#### Upper Bounded Wildcards

To write the method that works on lists of **Number** and its subtypes such as **Integer**, **Double**, and **Float**, we would use `List<? extends Number>`.

```java
public double sum(Integer<? extends Number> nums) {
   double s = 0.0;
   for (Number num : nums) s += num.doubleValue();
   return s;
}

List<Integer> ints = Arrays.asList(1, 2, 3);
assert sum(ints) == 6.0;

List<Double> doubles = Arrays.asList(2.78, 3.14);
assert sum(doubles) == 5.92;

List<Number> nums = Arrays.<Number>asList(1, 2, 2.78, 3.14);
assert sum(nums) == 8.92;
```

**EXCEPTION**: since `List<? extends Number>` sets an upper bound to **Number** and its subtypes, we can access the list elements as type **Number**, but cann't add anything except the value **null**, which belongs to every reference type:

```java
List<? extends Number> list = new ArrayList<>();
Number o = list.get(0);
list.add(Integer.valueOf(14)); // !!!! compile error
```

#### Unbounded Wildcards

`List<?>` - a list of unknown type. Has undefined type, thus we cann't add anything except **null**, but can retrieve the collection's elements as type **Object**.
```java
List<?> list = new ArrayList<>();
list.add(\"str\");  // !!!! compile error
Object elem = list.get(0);
```

There are two scenarios where an unbounded wildcard is a useful approach:
- if you are writing a method that can be implemented using functionality provided in the **Object** class.
- when the code is using methods in the generic class that don't depend on the type parameter. For example, `List.size` or `List.clear`. In fact, `Class<?>` is so often used because most of the methods in `Class<T>` do not depend on **T**.

For example, we have a method `printList(List<Object> list)` that print each element - it cannot print `List<Integer>`, `List<String>` and so on. Thus we should use `List<?>`, because for any concrete type **A**, `List<a>` is a subtype of `List<?>`.

#### Lower Bounded Wildcards

Restricts the unknown type to be a specific type or a **super type** of that type.

To write the method that works on lists of **Integer** and its supertypes such as **Integer**, **Number** and **Object**, we would specify `List<? super Integer>`:

```java
public void count(List<? super Integer> ints, int n) {
    for (int i = 0; i < n; i++) ints.add(i);
}

List<Integer> ints = new ArrayList<>();
count(ints, 5);
assert ints.toString().equals("[0, 1, 2, 3, 4]");

List<Number> nums = new ArrayList<>();
count(nums, 5); nums.add(5.0);
assert nums.toString().equals("[0, 1, 2, 3, 4, 5.0]");

List<Object> objs = new ArrayList<>();
count(objs, 5); objs.add("five");
assert objs.toString().equals("[0, 1, 2, 3, 4, five]");
```

**EXCEPTION**: since `List<? super Integer>` can contains **Integer** and its supertypes, we cannot get anything out from except a value of type **Object**, which is a supertype of **every reference type**.


-----


## Collections

![java collections .jpg](#file:95bda13d-dd9e-10bb-83b8-015b02e33215)

- Collection => Set, SortedSet, List, Queue
- Map => SortedMap

```java
interface Collection<E> extends Iterable<E> {
	int size();
    boolean isEmpty();
    boolean contains(Object e);
    Iterator<E> iterator();
}
```

#### Set

- HashSet
- TreeSet
- LinkedHashSet
- EnumSet
- CopyOnWriteArraySet

#### List

- ArrayList
- LinkedList
- CopyOnWriteArrayList
- Stack LIFO (last-in-first-out)
- Deque


#### Map

- HashMap
- LinkedHashMap
- TreeMap
- EnumMap
- WeakHashMap
- IdentityHashMap

#### Queue

```java
interface Queue<E> extends Collection<E> {
    E element();
    boolean offer(E e);
    E peek();
    E poll();
    E remove();
}
```

- LinkedList
- PriorityQueue
- ArrayDeque (implements Deque)



### Wrapper Implementations

Wrapper implementations delegate all their real work to a specified collection but add extra functionality on top of what this collection offers. All these implementations are found in the Collections class, which consists solely of static methods.

```java
Collections.synchronizedX(...);
Collections.unmodifiableX(...);
```


#### Algoritms from Collections

- sort
- shuffle
- reverse
- fill
- copy
- swap
- addAll
- binarySearch
- frequency
- disjoint
- min
- max
